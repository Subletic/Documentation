<<<

== Querschnittliche Konzepte

=== Kommunikation

Die Kommunikation mit externen Fremdsystemen sollte zum einen gekapselt sein, zum anderen getrennt in eine Klasse die sendet und einen die empfängt. Ist die Verbindung bidirektional, so sollte ein dritter Bereich beide Klassen verbinden und den WebSocket o.ä. verwalten.

==== Frontend zu Backend

Kommunikation die vom Frontend zum Backend verläuft, ist in unserem Fall zustandslos, es werden also keine Streams/Echtzeitdaten benötigt. Mithilfe einer REST-API, realisiert durch einen Controller, kann das Frontend Daten an das Backend übermitteln. Ein Controller sollte dabei nur für eine bestimmte Art von Daten zuständig sein, z.B. _SpeechBubbles_:

.Erstellen eines Controllers in ASP.NET Core:
[source,csharp]
----
[ApiController]
[Route("api/")]
public class MyNewController : ControllerBase
{
    public MyNewController(/*Injected Services and Parameters*/)
    {
        // Constructor
    }

    [HttpPost]
    [Route("domain/endpoint")]
    public IActionResult HandleUpdatedSpeechBubble([FromBody] DataTransferObject data)
    {
        // Handling of the received data
        return Ok();
    }
}
----

Im _BackendProviderService_ kann anschließend der neue REST-Endpunkt aufgerufen werden:

.Aufruf des REST-Endpunkts im Frontend:
[source,typescript]
----
export class BackendProviderService {
    public callNewEndpoint(dto: DTO): void {
    fetch(environment.BACKEND_URL + '/api/domain/endpoint', {
      method: 'POST',
      body: JSON.stringify(dto),
      headers: {
        'Content-Type': 'application/json',
      },
    }).then((response) => {
      console.log(response);
      if (response.ok) return;
      console.error('Error Message');
    });
  }
}
----

==== Backend zu Frontend

Kommunikation die vom Backend zum Frontend verläuft, ist teilweise zustandsbehaftet. Mit SignalR ist es dennoch möglich unaufgefordert dem Frontend Daten zu senden. Dazu kann der `hubContext` im _FrontendCommunicationService_ genutzt werden:

.Aufruf des SignalR-Endpunkts im Backend:
[source,csharp]
----
public class FrontendCommunicationService : IFrontendCommunicationService
{
    private readonly IHubContext<FrontendCommunicationHub> hubContext;

    public FrontendCommunicationService(IHubContext<FrontendCommunicationHub> hubContext)
    {
        this.hubContext = hubContext;
    }

    public async Task SendNewDataWithSignalR(DTO data)
    {
        try
        {
            var listToSend = new List<DTO>() { data };
            await hubContext.Clients.All.SendAsync("endpoint", listToSend);
        }
        catch (Exception ex)
        {
            logger.Error($"Failed to transmit to Frontend: {ex.Message}");
        }
    }
}
----

Im Frontend muss der Endpunkt im _backendListenerService_ erstellt und in der Komponente schließlich abonniert werden:

.Erstellen und abonnieren eines SignalR-Endpunkts im Frontend:
[source,typescript]
----
export class backendListener {
  private hubConnection: signalR.HubConnection;
  public data: Subject<DTO> = new Subject<DTO>();

  constructor() {
    this.hubConnection = new signalR.HubConnectionBuilder()
      .withUrl(environment.BACKEND_URL + '/endpoint')
      .build();

    this.hubConnection.on('newBubble', (data) => {
      this.newData.next(data);
    });
  }
}

// Abonnieren des Endpunkts in der Komponente:
ngOnInit(): void {
    this.backendListener.newData.subscribe((data) => {
      // Do something with the data
    });
}
----

=== Spezielle Code-Conventions

Da die Software von unerfahrenen Entwicklern entwickelt wird, muss im Besonderen auf die Softwarequalität geachtet werden. Häufig tun sich neue Entwickler schwer ihren Code so zu schreiben, dass er leicht verständlich und wartbar ist. Viele Schachtelungen, ungünstige angeordnete Abfragen und schlechte Namensgebung sind nur einige Beispiele die die Wartbarkeit des Codes erschweren. Im Folgenden werden einige Code-Conventions aufgeführt, die die Wartbarkeit des Codes verbessern und bei Code-Reviews kontrolliert werden.

==== Minimierung der Schachtelung

Die Entwickler sollten das Schachteln von vielen Schleifen und if-Abfragen vermeiden. Dabei können die folgenden Techniken helfen:

.Verwendung von Guard-Clauses:
[source,csharp]
----
// Bad:
if (condition) {
    if (condition2) {
        if (condition3) {
            // do something
        }
    }
}

// Good:
if (!condition) return;
if (!condition2) return;
if (!condition3) return;

----

.Verwendung von 'switch'-Statements:
[source,csharp]
----
// Bad:
if (condition) {
    // do something
} else if (condition 2) {
    // do something
} else {
    // do something
}

// Good:
switch (condition) {
    case 1: /*do something*/ break;
    case 2: /*do something*/ break;
    default: /*do something*/ break;
}
// Or:
switch (condition) {
    case 1: /*do something*/ return;
    case 2: /*do something*/ return;
    default: /*do something*/ return;
}
----

.Innere Schleifen auslagern oder Linq verwenden:
[source,csharp]
----
private List<string> textblock = new List<string>();

// Bad:
private bool TextblockContainsQuestionmark() {
    foreach (word in textblock) {
        for (int i = 0; i < word.Length; i++) {
            if (word[i]).Contains("?") {
                return true;
            }
        }
    }
}

// Good:
private bool TextblockContainsQuestionmark() {
    foreach (word in textblock) {
        return WordContainsQuestionmark(word);
    }
}
private bool WordContainsQuestionmark(string word) {
    for (int i = 0; i < word.Length; i++) {
        if (word[i]).Contains("?") {
            return true;
        }
    }
}

// Better:
private bool TextblockContainsQuestionmarkWithLinq() {
    foreach (word in textblock) {
        return word.Any(c => c == '?');
    }
}
----

==== Lose Kopplung und Kapseln von Funktionalität

Das Kapseln von Funktionalität ist entscheidend für die Wartbarkeit des Codes, da sie die Komponenten lose koppelt. Das Facade-Pattern oder Interfaces im allgemeinen helfen dabei, die Funktionalität zu kapseln und für eine lose Kopplung zu sorgen. Ein Beispiel ist die Kapselung der Kommunikation zwischen Backend und Frontend. Sobald eine Komponente mit dem jeweils andern System kommunizieren möchte, stellt sie eine Anfrage an eine Facade, zB im Backend der _FrontendCommunicationService_. Dieser Service kapselt die Kommunikation mit dem Frontend und stellt eine Schnittstelle für die anderen Komponenten bereit. Aber auch das Verwenden eines Interfaces beim Erstellen einer neuen Klasse, hilft dabei auch in Zukunft die Software leicht erweiterbar zu halten:

.Verwendung eines Interfaces im Kontext der Untertitelerstellung
[source,csharp]
----
public interface ISubtitleConverter
{
    public void ConvertSpeechBubble(SpeechBubble speechBubble);
}

public class WebVttConverter : ISubtitleConverter
{
    public WebVttConverter() { }

    public void ConvertSpeechBubble(SpeechBubble speechBubble)
    {
        // Convert SpeechBubble to WebVtt
    }
}
----

==== Dependency Injection

Dependency Injection ist ein weiteres Entwurfsmuster, dass die Abhängigkeiten zwischen Komponenten eines Systems löst, indem es externe Abhängigkeiten in eine Komponente injiziert, anstatt dass die Komponente sie selbst erstellt. Dazu wird einfach das entsprechende Objekt als Parameter im Konstruktor übergeben. Dies fördert lose Kopplung, erleichtert Testbarkeit und verbessert die Wartbarkeit von Code.

Ein konkretes Beispiel ist die Verwendung eines externen Services im Backend. Erstellen wir zB. einen Service, können wir unseren Umgebungs-Variablen die in der `appsettings` stehen im Konstruktor injizieren, anstatt ihn selbst zu erstellen:

.Dependency Injection am Beispiel eines Services:
[source,csharp]
----
private readonly IConfiguration configuration;
private readonly int appsettings_Variable;

public MyService(IConfiguration configuration)
{
    this.configuration = configuration;
    this.appsettings_Variable = configuration.GetValue<int>("MyServiceSettings:veryImportantVariable");
}
----
