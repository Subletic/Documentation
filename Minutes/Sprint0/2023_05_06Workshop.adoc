= Protokoll 06.05.2023 (C# und Nunit Workshop)

== Teilnehmer
* Benedikt Beigang (beng)
* Amine Jegani (jene)
* Chantal Bley (chey)
* Pascal Fabian Dittes (paes)
* Luca Niklas Franke (luke)
* Christoph Neidahl (chhl)
* Finn Johann Romeis (fiis)

== Agenda

Startzeit/Endzeit: 15:00

=== Organisation

****
* Wie erstellt man Branches und MergeRequests
* Wie installiert man die https://dotnet.microsoft.com/en-us/de/download[.NET-SDK]
* Wie installiert man https://code.visualstudio.com/[Visual Studio Code]
****

=== Workshop

==== Einrichten

* Anlegen der richtigen Ordnerstruktur

****
```
WorkshopAufgabe
|--> WorkshopAufgabe
|--> WorkshopAufgabeTests
```
****

* Anlegen einer neuen Konsolen-App
** `dotnet new console`
** `dotnet run`
* Anlegen eines neuen Nunit-Projekts
** `dotnet new nunit`
** `dotnet test`
* CodeRunner fürs Debuggen


==== Schreiben der Tests

Unterschiedliche Vorgehensweisen möglich zB: Test-Last Development oder Test-Driven-Development

****
**Setup()**

Die SetUp-Methode ist eine spezielle Methode, die in Unit-Tests verwendet wird, um den Testkontext vorzubereiten, d.h. um vor dem Ausführen jedes Tests bestimmte Vorbereitungen zu treffen. Die SetUp-Methode wird vor jedem einzelnen Test in der Testklasse aufgerufen.

```csharp
[SetUp]
public void Setup()
{
    _optimizer = new RecursiveRouteOptimizer();
}
```
****

****
**Test()**

Die Testmethoden dienen dazu, spezifische Tests für einzelne Funktionalitäten oder Szenarien einer Anwendung zu definieren. Jede Testmethode enthält den eigentlichen Testcode, der überprüft, ob das erwartete Verhalten einer bestimmten Funktion oder eines bestimmten Teils der Anwendung erfüllt wird.

Die Benennung eines Tests erfolgt immer nach dem selben Muster:

**<NamerDerMethode>_<TestFall>_<ErwartetesVerhalten>**

Ein Beispiel ist z.B.:

```csharp
[Test]
public void Optimizer_TwoDirectionsRouteBeingUnnecessary_EmptyListReturned()
{
    // ...
}
```

Auch der Aufbau des Tests folgt immer dem selben Muster:

```csharp
[Test]
public void Optimize_TwoDirectionsRouteBeingUnnecessary_EmptyListReturned()
{
    // Arrange
    List<Direction> input = new List<Direction>() { Direction.North, Direction.South, Direction.North, Direction.South };
    List<Direction> expected = new List<Direction>() { };

    // Act
    List<Direction> result = _optimizer.Optimize(input);

    // Assert
    Assert.That(result, Is.EqualTo(expected));
}
```

*****
**Arrange**

In diesem Abschnitt werden die erforderlichen Vorbedingungen oder der Testkontext eingerichtet. Hier werden Objekte initialisiert, Eingabewerte festgelegt und andere Vorbereitungen getroffen, um den Zustand der Anwendung vor dem eigentlichen Test zu konfigurieren.
*****

*****
**Act**

In diesem Abschnitt wird die Aktion oder der Code ausgeführt, der getestet werden soll. Es handelt sich um den eigentlichen Aufruf der zu testenden Methode oder Funktion, bei dem bestimmte Aktionen oder Berechnungen ausgeführt werden.
*****

*****
**Assert**

In diesem Abschnitt wird überprüft, ob das Verhalten oder das Ergebnis der Aktion den erwarteten Ergebnissen entspricht. Es werden Assertions verwendet, um sicherzustellen, dass bestimmte Bedingungen oder Eigenschaften erfüllt sind. Wenn eine Assertion fehlschlägt, gilt der Test als nicht bestanden.
=> https://docs.nunit.org/articles/nunit/writing-tests/assertions/assertions.html[Assert Doku]
*****

Es sollten alle erdenklichen Szenarios getestet werden. Es ist dabei Aufgabe des Entwicklers selbst zu entscheiden ob ein Test notwendig ist. Eine gute Herangehensweise bei der Frage ob ein Test notwendig ist, ist sich die Frage zu stellen: **Schafft der Test neue Sicherheit?**

Gut geschriebener Code führt zu guter Testbarkeit. Infolge dessen sollte das Schreiben eines Tests keine große Mühe machen. Falls dies jedoch der Fall ist, ist dies ein Indiz dafür, dass der Code refaktorisiert werden sollte.
****

==== Mocks

****
Viele Klassen und Methoden haben externe Abhängigkeiten zu anderen Stellen des Codes, Dateien, APIs, etc. In Tests stören diese Abhängigkeiten, da es scheint den Code nicht testen zu können. Mocks erlauben es diese externen Abhängigkeiten zu trennen. Im Kontext von nUnit-Tests kann die `Moq`-Bibliothek verwendet werden. Es lassen sich so Klassen und Methoden mocken, sodass die Abhängigkeit im Test immer das selbe zurückgibt. Für den Test selbst ist dieser Mechanismus aber unsichtbar.


**Beispiel Code:**
```csharp
public interface IFileReader
{
    string ReadFile(string filePath);
}

public class FileProcessor
{
    private IFileReader fileReader;

    public FileProcessor(IFileReader reader)
    {
        fileReader = reader;
    }

    public string ProcessFile(string filePath)
    {
        // Logik zur Verarbeitung der Datei
        string fileContent = fileReader.ReadFile(filePath);
        // ...
        return processedData;
    }
}
```

**Gemockter Test-Code:**
```
using Moq;
using NUnit.Framework;

[TestFixture]
public class FileProcessorTests
{
    [Test]
    public void ProcessFile_ValidFileContent_ReturnsProcessedData()
    {
        // Arrange
        string mockFileContent = "Mocked file content";
        string expectedProcessedData = "Processed data";
        string filePath = "dummy/file/path.txt";

        var fileReaderMock = new Mock<IFileReader>();
        fileReaderMock.Setup(reader => reader.ReadFile(filePath)).Returns(mockFileContent);

        var fileProcessor = new FileProcessor(fileReaderMock.Object);

        // Act
        string result = fileProcessor.ProcessFile(filePath);

        // Assert
        Assert.AreEqual(expectedProcessedData, result);
    }
}
```

Im oberen Beispiel wird in der Methode `ProcessFile()` ein externe Abhängigkeit aufgebaut zu einer Datei, durch die Methode `fileReader.ReadFile(filePath)`.

> `fileReaderMock.Setup(reader => reader.ReadFile(filePath)).Returns(mockFileContent);`

Durch das Setup des Mockobjekts wird der `IFileReader` gemockt. Wird im Test bzw. bei der Ausführung die Zeile `string fileContent = fileReader.ReadFile(filePath);` aufgerufen, so gibt der Mock den `mockFileContent` zurück.

Möglich wird dies durch die sogenannte **Dependency Injection**. Dies bedeutet das die externen Abhängigkeiten einer Klasse im Konstruktor der Klasse übergeben werden. In unserem Fall wird der `IFileReader reader` der Klasse übergeben.
****

=== Tipps and Tricks für Java Entwickler die mit C# arbeiten müssen

*****
**foreach**
```csharp
foreach(string s in stringArray){

}
```
*****

*****
**Kurze Getter und Setter**
```csharp
public class Program{
    public string Attribut { get; set; }
}
```
*****

*****
**Ternärer bedingter Operator**
```csharp
int value = (a < b) ? 2 : method();
```
*****

*****
**is / is not statt == / !=**
```csharp
if (method() is not method())
```
*****


*****
**readonly (erzwungene Initialisierung im Konstruktor)**
```csharp
public class Program{
    public readonly string Attribut;

    public Program(){
        Attribut = "";
    }
}
```
*****

*****
**regions**
```csharp
#region Checker

public void CheckMethod1(){

}

public void CheckMethod2(){

}

#endregion
```
*****

*****
**Linq (Lambda-Funktionen auf Datenstrukturen)**
```csharp
List<int> liste = new List<int>(){ 1, 2, 3, 4, 4, 6 };
liste.Any(x => x == 2); // Beinhaltet 2 => true
liste.FindAll(x => x == 4); // Alle vorkommen von 4 zurückgeben => { 4, 4 }
// ...
```
*****

*****
**NullTypes**
```csharp
public string? Method1(){

}

public void Method2(){
    string value = Method1(); // Warnung da Methode 1 nen null zurückgibt
    string value2 = Method1()!; // ! überschreibt die Warnung, Entwickler garantiert, dass kein null zurückkommt 
}
```
*****

*****
**Default-Values in Parameter**
```csharp
public string Method1(int val1, int val2 = 10){

}
```
*****

*****
**Arrays**
```csharp
int[,] arr = new int[5,10];
```
*****

*****
**Vererbung und Interfaces**
```csharp
public class BaseClass{

}

public interface ExampleInterface{

}

public class DerivedClass : BaseClass, ExampleInterface{

}
```
*****