= Poster Inhalt

== Zielstellung

Live-Untertitelung existiert schon heute, wie die automatische Untertitelung von YouTube zeigt. Diese ist jedoch noch fehleranfällig und eignet sich daher nicht für Live-Streams bei denen Wert auf Korrektheit gelegt wird, wie bei Landtagsdebatten. Dabei bergen diese Technologien das Potenzial, Berufsgruppen wie Stenografen zu entlasten und lässt Menschen die auf Untertitel angewiesen sind, zusätzlich von besserer Untertitelung profitieren. Unser Ziel ist es, bereits heute existierende Software für automatische Untertitelung, um Echtzeit Korrektur zu ergänzen. Dabei sollen die Bedürfnisse von Stenografen mitgedacht und die DSGVO-Konformität eingehalten werden. Somit kann unsere Software überall da eingesetzt werden, wo es auf korrekte Untertitel und Datenschutz ankommt.

== Funktionalitäten

Unser MVP erlaubt es unserem Nutzer hereinkommende Transkriptionen, sogenannte Sprechblasen, zu sehen und zu editieren. Jede Sprechblasen besteht aus einigen Wörtern, welche in einer Liste zusammengefasst sind. Dies garantiert die Übersichtlichkeit der Software. Zudem werden Wörter bei dem sich das Transkriptions-Tool unsicher ist, farbig markiert. Zusätzlich zur reinen visuellen Repräsentation des Gesagten, ist laufend das Audio des Video-Streams zu hören, sodass der Anwender sich vergewissern kann, die Sprechblasen richtig zu Korrigieren. Fallen Sprechblasen und der Audio-Stream aus dem Zeitfenster, so werden diese wieder mit dem Video zusammengeführt und sind damit bereit für den Export.

== Technologien

Unsere Software setzt auf ASP.NET 7 im Backend und Angular 16 im Frontend. Zur Erstellung der Untertitel nutzen wir Speechmatics, ein Transkriptions-Tool, dass auch in der Software unseres Kunden Verwendung findet. Für das Streaming der Untertitel und der Audio zum Frontend, setzten wir auf SignalR, eine .NET Bibliothek die das Hinzufügen von Echtzeit-Webfunktionen erlaubt. Um mit verschiedenen Stream-Formaten intern umgehen zu können, nutzen wir FFmpeg im Backend und die Web Audio API im Frontend. Das Deployment wird durch ein geteiltes Docker-Image für Frontend und Backend realisiert, in einer Docker-Compose zusammengeführt und dann via PodMan deployed.